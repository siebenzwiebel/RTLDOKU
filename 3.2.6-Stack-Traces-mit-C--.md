Beim Entwickeln auf Windows verwendet man meist eine IDE, die über einen Debugger verfügt. Sollte die Anwendung einmal abstürzen, so kann man die Anwendung im Debug Modus starten und das Programm hält an, wenn der Fehler auftritt. Im Debugger der IDE kann man den aktuellen Stack bequem inspizieren und so den Fehler sehr einfach ausfindig machen. Auf dem Raspberry Pi steht jedoch keine IDE mit einer solchen Funktionalität zur Verfügung. Mittels `gdb` kann man zwar ein Programm im Terminal debuggen, aber sich einfach mal einen Stacktrace anzeigen lassen, ist nicht so einfach. Aus diesem Grund bestand der Wunsch, im Falle eines Crashes einen Stacktrace auf der Konsole zu bekommen. Denn nur über Loggerausgaben einen Fehler zu finden ist sehr mühsam, da man die Zeile, in der der Fehler entsteht, nur einfach finden kann, wenn es nach quasi jeder Zeile eine Loggerausgabe gibt. Dies so zu implementieren wäre jedoch nicht sinnvoll. In anderen Programmiersprachen wie z.B. Java, die in einer Laufzeitumgebung laufen, ist dies der Standard, wenn ein Fehler auftritt. Hier weiß die entsprechende Laufzeitumgebung bereits den Stack. In C++ ist der Stack jedoch sehr stark plattform- und implementierungsunabhängig. Man erhält recht einfach die Adressen der aufgerufenen Funktionen, aber diese Adressen den ursprünglichen Symbolen im Programm zuzuordnen ist nicht trivial und ebenfalls sehr stark plattform- und implementierungsunabhängig. Aus diesem Grund wurde die Library Boost.Stacktrace verwendet. Sie kann grundsätzlich auf jeder Plattform den aktuellen Stack analysieren und ausgeben, jedoch funktionierte das Mappen von Speicheradressen auf Symbole im Programm nur auf dem Raspberry Pi. Da auf Windows kein Stacktrace benötigt wurde, da diese Funktionalität von der IDE übernommen wird. 

Tritt in einem C/C++ Programm ein Fehler auf,  so löst der 
Betriebssystemkernel ein Signal aus, z.B. ein `SIGSEGV` Signal bei einem Speicherzugriffsfehler, und beendet das Programm. Ein Programm kann jedoch Signalhandler registrieren, die bei einem Signal noch die letzte Möglichkeit haben, Code auszuführen. Im Falle eines Signals wird in der Anwendung nun auf dem Raspberry Pi der Stack mittels Boost.Stacktrace ausgeben und die Anwendung anschließend beendet.