## 3.3.1 Motivation

Für die Softwarearchitektur dieses Projektes wurden folgende Oberziele angestrebt:

Durch die Aufteilung in kleine Komponenten wird eine einfache Testbarkeit erreicht. Es muss nicht die komplette Anwendung gestartet werden, sondern es reicht, nur eine Komponente zu initialisieren. 

Dadurch, dass die Komponenten sehr klein sind, macht eine Komponente nur eine Sache. So wird die Fehlersuche stark vereinfacht, da man im Idealfall nur in einer Komponente schauen muss. 

Unter dem Komponenten wird eine möglichst lose Koppelung angestrebt, um ein einfaches Austauschen und erweitern zu ermöglichen.

Da Third Party Libraries nicht unter der eigenen Kontrolle stehen,  sollten sie wenn möglich in einer Komponente gekapselt werden. So können sie einfach entfernt bzw. ausgetauscht werden, wenn z.B. die Entwicklung eingestellt wird.

## 3.3.2 Separation von GUI und Core

Grundlegend wurden in diesem Projekt die GUI von der restlichen Anwendung entkoppelt. Dazu wurde die Anwendung in die Komponenten  `ui`und  `core`aufgeteilt.  `ui`enthält den Code, der für die Benutzeroberfläche notwendig ist.  `core`enthält die Funktionalität zur Generieren und Abspielen der Lightshow.  `core`hat keinerlei Kenntnis von  `ui`, sondern bekommt alle Informationen, benötigt werden, beim Methodenaufruf übergeben.  `ui`ruft lediglich Methoden von  `core`auf und ist als einzige Komponente im Projekt vom verwendeten GUI-Framework ab. Auf diese Weise kann die Benutzeroberfläche mit einer anderen Technologie implementiert werden, ohne das etwas an der Lightshow Logik geändert werden muss. Da  `core`so auch ohne GUI existieren kann, ist es möglich, basierend auf  `core`jede Art von Anwendung zu schreiben, die keine Benutzeroberfläche haben. So war es beispielsweise möglich, die Generierung der Lightshow zu entwickeln, ohne das die dafür benötigten Aktionen in der GUI implementiert sein mussten.

`core`wird als statische Library kompiliert und  `ui`wird statisch gegen  `core`gelinkt. So erhöht sich die Performance beim Kompilieren, da bei Änderungen an  `ui`nur der Code von  `ui`neu kompiliert werden muss, da  `core`ja keinerlei Abhängigkeiten zu  `ui`hat.

## 3.3.3 Logging

In der Anwendung erfolgen keine Ausgaben über `std::cout` oder `std::cerr`, alle Ausgaben erfolgen über die Klasse `Logger`. `Logger` schreibt derzeit lediglich auf die Konsole. Sollte einmal in eine Datei geloggt werden, so muss lediglich die Konfiguration von `Logger` angepasst werden. 

Die Klasse `Logger` kapselt das Logging-Framework und konfiguriert es den Bedürfnissen der Anwendung entsprechend. Alle Logging-Aufrufe in der Anwendung verwenden `Logger`, die die entsprechenden Aufrufe an der verwendete Logging-Framework weiterreicht. Sollte sich die verwendete Logging-Library als nicht mehr geeignet herausstellen, so muss lediglich die Klasse `Logger` angepasst werden. Da ein Logger naturgemäß überall in der Anwendung aufgerufen wird, kann in diesem Fall auf das Anpassen aller Logging-Aufrufe verzichtet werden.

## 3.3.4 DMX-Interfaces

Die Entwicklung der Anwendung begann mit dem DMX Interface K8062. Da neben diesem DMX Interface noch weitere auf dem Markt erhältlich sind, war es wichtig, die Anwendung nicht nur auf ein bestimmtes Interface festzulegen. Generell sollte natürlich die Interaktion mit dem DMX Interface gekapselt werden, damit die Logik dafür zentral an einer Stelle verwaltet werden kann. Aus dieser Kapselung wurde noch die abstraktes Klasse DmxDevice extrahiert. So kann die Lightshow einfach über polymorphe Methodenaufrufe das tatsächlich angeschlossene DMX Interface ansprechen, ohne wissen zu müssen, um welches DMX Interface es sich wirklich handelt und wie die Daten übermittelt werden müssen. Als sich im Laufe des Projektes Probleme durch Limitierungen in der Hardware des K8062 zeigten, konnte eine neue Implementierung aus Sicht der Softwarearchitektur sehr leicht hinzugefügt werden. Es musste lediglich eine neue Implementierung von DmxDevice sowie eine Funktion, die den Typen des aktuell verbundenen DMX Interfaces erkennt, geschrieben werden

## 3.3.5 MusicPlayer

|               | Windows        | Raspberry 3,Ubuntu Mate | Raspberry 3 Raspbian | Raspberry Pi 4 Raspbian |
|---------------|----------------|-------------------------|----------------------|-------------------------|
| Qt Multimedia | ja             | nein                    | nein                 | nein                    |
| Portaudio     | nein           | ja                      | ja                   | ja                      |
| NFDriver      | nicht getestet | ja                      | ja                   | nicht getestet          |
| GStreamer     | nicht getestet | nein                    | nein                 | nein                    |

Da unsere Anwendung auch Musik abspielen soll, musste eine entsprechende Library ausgewählt werden, die das Abspielen für uns übernimmt. Für die Benutzeroberfläche wurden bereits gute Erfahrungen mit Qt gesammelt und da Qt auch ein Multimedia Framework enthält, war es naheliegend, auch dieses zu verwenden. Das Qt Multimedia Framework stellt den QMediaPlayer zur Verfügung, der High Level Funktionalitäten zum Abspielen von Musik zur Verfügung. Es muss nur ein Pfad zu einer Audiodatei angegeben werden und alles weitere wird vom QMediaPlayer behandelt. Der QMediaPlayer verwendet ebenfalls das Signal / Slot System von Qt, sodass er einfach in die bestehende Qt Anwendung integriert werden konnte. Aufgrund der Entwicklungsgeschwindigkeit wurde der QMediaPlayer zuerst auf Windows implementiert. Beim Testen auf dem Raspberry Pi stellte sich jedoch heraus, dass mit dem QMediaPlayer kein Sound auf dem Raspberry Pi ausgegeben wurde. Das Problem konnte durch Debuggen jedoch nicht gefunden werden, eine Recherche ergab, dass eventuell ein eigener Build von Qt helfen könnte. Intern verwendet Qt auf Linux jedoch GStreamer zum Abspielen von Sound. Daher wurde zuerst GStreamer als Standalone Lösung getestet. Dies brachte jedoch auch keinen Erfolg. Aus diesem Grund wurden nach einem anderen Audiowiedergabe Framework gesucht, das auf dem Raspberry Pi funktioniert. Dazu wurden NFDriver und Portaudio getestet. Beide Libraries funktionieren auf dem Raspberry Pi, da die Portaudio API jedoch eine bessere Kontrolle bietet, wurde Portaudio ausgewählt. Portaudio funktioniert jedoch nicht unter Windows. Da sich das hauptsächliche Entwickeln auf Windows und anschließendes Testen auf dem Raspberry Pi jedoch bewährt hatte und die Entwicklungsgeschwindigkeit bei ausschließlichem Entwickeln auf dem Pi sehr gelitten hätte, musste auch Windows weiterhin supportet werden. Aus diesem Grund wurde folgende Lösung ersonnen: Die Wiedergabe von einzelnen Songs wird in eine abstrakte Klasse `SongPlayer` ausgelagert. `MusicPlayer` übernimmt die Wiedergabe von Playlisten und verwendet für die Wiedergabe eines Songs `SongPlayer`. Für `SongPlayer`  gibt es zwei Implementierungen, eine mit dem QMediaPlayer für Windows, den `QMediaSongPlayer`, und eine mit Portaudio für den Raspberry Pi, den `PortAudioSongPlayer`.

`SongPlayerFactory` stellt die Factory Methode `create_song_player` zur Verfügung, die einen `SongPlayer` erstellt. Die `SongPlayerFactory` erkennt zur Compilezeit mittels durch Präprozessoranweisungen, ob gerade für den Raspberry Pi oder für Windows kompiliert wird. Dann wird die entsprechende Implementierung beim Aufruf von `SongPlayerFactory::create_song_player` zurückgegeben. Ein `SongPlayer` darf nur von der `SongPlayerFactory` erzeugt werden, so wird sichergestellt, dass immer nur die korrekte `SongPlayer` Implementierung für das aktuelle Betriebssystem instanziiert wird.

Beide Implementierungen werden als eigene statische Library kompiliert und mit dem Rest des Projektes statisch gelinkt. CMake konfiguriert den Build so, dass die zu dem aktuellen Betriebssystem nicht kompatible Implementierung nicht kompiliert wird. So hat das Projekt keine Abhängigkeit zu der gerade nicht verwendeten Audio Library. Auf Windows wird zum Bauen der Anwendung also kein Portaudio benötigt und auf dem Raspberry Pi wird kein QtMultimedia benötigt.

Bei der ersten Wiedergabe der Anwendung wurde der QMediaPlayer jedoch nur unzureichend gekapselt und viele Klassen hatten eine direkte Abhängigkeit zum QMediaPlayer. Dadurch war beim Umstellen des Projektes ein umfangreiches Refactoring nötig. Dabei durfte natürlich die Funktionalität des Programmes nicht beschädigt werden. Darum wurde die Funktionalität nach und nach von QMediaPlayer auf den SongPlayer umgestellt und immer nur genau eine Stelle im Programm geändert. So konnten Auswirkungen einer Änderung und eventuelle Fehler schnell gefunden und behoben werden.