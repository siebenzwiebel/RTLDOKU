
Erste Tests ergaben, dass der Raspberry Pi zu langsam ist, als das man produktiv größere Projekte direkt auf dem Raspberry Pi entwickeln könnte. Die Zeiten beim Kompilieren waren bis zu zehnmal so hoch wie auf einem normalen Desktop Computer.
Als Alternative dazu gab es folgende Optionen: 
*   auf einem Desktoprechner entwickeln und mittels Cross Compiling Binaries für den Raspberry Pi auf dem Desktopcomputer erzeugen
*   Auf einem Desktoprechner entwickeln und auf dem Raspberry Pi Binaries für den Raspberry Pi erzeugen

Native Binaries, die auf von einem C++ Compiler auf einem Desktopcomputer erzeugt werden, können normalerweise nicht auf dem Raspberry Pi ausgeführt werden. Ein normaler Desktopcomputer verfügt über eine x86-CPU, die ein x86-Befehlssatz ausführen kann. Der Raspberry Pi hat jedoch eine andere CPU Architektur, in ihm steckt eine ARM CPU mit einem anderen Befehlssatz. Es gibt jedoch die Möglichkeit, auf einem x86 Rechner einen Compiler zu verwenden, der anstelle von x86 ARM Binaries produziert. Dieser Vorgang wird als Cross Compiling bezeichnet, da die Zielarchitektur eine andere ist als die Architektur, auf der der Compiler ausgeführt wird. 

Die Option der Cross Compilings klang am sinnvollsten, da so für beide Plattformen eine hohe Geschwindigkeit beim Kompilieren erreicht werden könnte. Aus diesem Grund wurde diese Option evaluiert. 

Das Ergebnis dieser Evaluation war: Cross Compiling ist nur mit einem für dieses Projekt zu großem Aufwand machbar. Getestet wurde eine eine einfach Hello World Anwendung für das Terminal sowie ein grafisches Hello World mit Qt. Die einfache Hello World Anwendung konnte problemlos auf einen Desktopcomputer kompiliert und erfolgreich auf dem Raspberry Pi ausgeführt werden. Zum Kompilieren musste hier lediglich ein anderer Compiler aufgerufen werden. Die Qt Anwendung stellte sich als Herausforderung da. 

Zu Beginn dieser Evaluation war nicht bekannt, das es fertige Qt Binaries für die ARM-Architektur gibt. Damit mit dem grafischem Qt Hello World begonnen werden konnte, wurde zuerst versucht, Qt für den Raspberry Pi mittels Cross Compiling zu übersetzen. Dabei zeigten sich die Probleme, die es beim Cross Compiling geben kann. GUI Frameworks wie Qt haben viele Abhängigkeiten an die Zielplattform, da sie mit vielen APIs des Zielbetriebssystems interagieren müssen. Dementsprechend muss Qt beim Buildvorgang mit den entsprechenden Libraries der Zielplattform gelinkt werden. Dazu benötigt der Linker jedoch Zugriff auf die entsprechenden Dateien. Deswegen muss ein Raspberry Pi Image, auf dem bereits die entsprechenden Abhängigkeiten installiert wurden, auf den Desktopcomputer transferiert werden. Dazu wird einfach der Inhalt der SD-Karte in einen Ordner auf dem Desktopcomputer kopiert. Nun befinden sich die entsprechenden Dateien zwar auf dem Desktopcomputer, allerdings macht Linux sehr starken Gebrauch von Symbolic Links. So kommt es, dass die Libraries zwar an den richtigen Stellen sind, aber in Wirklichkeit sind es keine Dateien, sondern Symbolic Links, die an einen anderen Ort im Dateisystem verweisen. Leider beziehen sich die Symbolic Links noch auf Orte im Dateisystem auf der SD-Karte vom Raspberry Pi und funktionieren dementsprechend nicht mehr auf dem Desktoprechner. Diese Symbolic Links zu reparieren ist sehr kompliziert. Qt möchte beispielsweise unter anderem gegen die libpng Library gelinkt werden. Es reicht jedoch nicht aus, einfach nur dem Symlink zu der libpng Library zu reparieren, denn libpng hat selbst auch Abhängigkeiten zu anderen Libraries, die ebenfalls repariert werden müssen. Auch kann ein Symlink einen anderen Symlink verweisen, der ebenfalls repariert werden müssen. Falls man am Ende einer Reihe von Symbolic Links schlussendlich doch an einer echten Datei angekommen ist, kann es sein, dass es in den Binärdateien noch eine weitere Indirektion gibt, die ebenfalls repariert werden muss. Qt hat etwa 105 Abhängigkeiten, die als Pakete auf jeden fall nachinstalliert werden müssen. Alle diese Symlinks zu reparieren, wäre im Rahmen dieses Projektes nicht machbar gewesen, denn dies erfordert sehr gute Kenntnisse der Linux Plattform. Außerdem wurde herausgefunden, das es fertige Qt Binaries für die ARM-Architektur gibt, die auf dem Raspberry Pi einfach mittels apt installiert werden können. Dies hätte jedoch das Problem der nicht funktionierenden Symbolic Links nicht gelöst. Aus diesem Grund wurde sich gegen Cross Compiling entschieden. 

Entwickelt wurde also auf Windows und Binaries für den Raspberry Pi wurden auf den Raspberry Pi selbst kompiliert. 


### Entwicklung auf mehreren Plattformen

Da auf mehreren Plattformen entwickelt wurde, war es wichtig, sich darauf zu einigen, welche Compiler verwendet werden sollen. C++ ist zwar standardisiert, aber einige Compiler binden manchmal einige Header für den User automatisch ein, sodass dieser Code unter Umständen mit einem anderen Compiler nicht funktioniert. Da die Anwendung am Ende auf dem Raspberry Pi laufen sollte, war der Raspberry Pi die Referenz für alle Entscheidungen. 

Unter Linux und somit auch auf dem Raspberry PI wird standardmäßig der Gnu C++ Compiler verwendet. Unter Mac OS ist der Standardcompiler Apple Clang. Apple Clang ist jedoch zu dem Gnu C++ Compiler kompatibel und benutzt z.B. die gleichen Kommandozeilenflags, sodass dies kein Problem darstellt. Unter Windows ist der Standard C++ Compiler der Visual Studio Compiler. Der Visual Studio Compiler funktioniert jedoch komplett anders als der Gnu C++ Compiler, sodass mögliche Probleme erst beim Kompilieren auf dem Raspberry Pi auffallen würden. Dies sollte jedoch weitgehend unterbunden werden, um eine höhere Entwicklungsgeschwindigkeit zu ermöglichen. Aus diesem Grund wurde entschieden, unter Windows den MinGW Compiler zu verwenden. Der MinGW Compiler ist ein Port des Gnu C++ Compilers auf Windows, mit dem sich Windows Binaries erzeugen lassen. Die Verwendung des MinGW Compilers unter Windows bereitete keine Probleme.